
(define (lex metamath-string)
  (string-tokenize metamath-string))

(define (split-at tok tokens)
  (let walk ((path '()) (tokens tokens))
    (cond ((null? tokens) (values (reverse path) '()))
          ((equal? tok (car tokens)) (values (reverse path) (cdr tokens)))
          (else (walk (cons (car tokens) path) (cdr tokens))))))


(define (check-include file level)
  (unless (file-exists? (expand-metachez-path file))
    (error 'parse "include-stmt file does not exist" file tokens))
  (unless (zero? level)
    (error 'parse "include-stmt inside scope" tokens))
  'ok)

(define (parse tokens)
  (let ((includes (make-hashtable string-hash string=?)))
    (let walk ((tokens tokens) (level 0))
      (match tokens
        (() '())
        (("$(" rest ...)
         (let-values (((_ rest) (split-at "$)" rest)))
           (walk rest level)))
        (("$[" file "$]" rest ...)
         (check-include file level)
         (if (hashtable-ref includes file #f)
             (walk rest level) ;; level must be 0, checked by check-include
             `(,@(run-parser file) . ,(walk rest level))))
        (("${" rest ...)
         (let-values (((stmt rest) (split-at "$}" rest)))
           `((scopeing-stmt ,(walk stmt (1+ level))) . ,(walk rest level))))
        (("$c" rest ...)
         (let-values (((stmt rest) (split-at "$." rest)))
           `((constant-stmt ,@stmt) . ,(walk rest level))))
        (("$v" rest ...)
         (let-values (((stmt rest) (split-at "$." rest)))
           `((variable-stmt ,@stmt) . ,(walk rest level))))
        (("$d" rest ...)
         (let-values (((stmt rest) (split-at "$." rest)))
           `((disjoint-stmt ,@stmt) . ,(walk rest level))))
        ((name "$f" typecode var "$." rest ...)
         `((floating-stmt ,name ,typecode ,var) . ,(walk rest level)))
        ((name "$e" typecode rest ...)
         (let-values (((stmt rest) (split-at "$." rest)))
           `((essential-stmt ,name ,typecode ,stmt) . ,(walk rest level))))
        ((name "$a" typecode rest ...)
         (let-values (((stmt rest) (split-at "$." rest)))
           `((axiom-stmt ,name ,typecode ,stmt) . ,(walk rest level))))
        ((name "$p" typecode rest ...)
         (let-values (((lhs rest) (split-at "$=" rest)))
           (let-values (((rhs rest) (split-at "$." rest)))
             `((provable-stmt ,name ,typecode ,lhs ,rhs) . ,(walk rest level)))))
        (_ (error 'parse "TODO" tokens))))))

(define (run-parser file)
  (let ((program (file->string (expand-metachez-path file))))
    (parse (lex program))))
