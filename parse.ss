
(define (lex metamath-string)
  (string-tokenize metamath-string))

(define (file->statements file)
  (lex (file->string (expand-metachez-path file))))

(define (split-upon tok tokens)
  (let walk ((tokens tokens) (path '()))
    (cond ((null? tokens) (values (reverse path) '()))
          ((equal? tok (car tokens)) (values (reverse path) (cdr tokens)))
          (else (walk (cdr tokens) (cons (car tokens) path))))))

(define (split-scoped tokens)
  (let walk ((tokens tokens) (path '()) (level 0))
    (cond ((null? tokens))
          ((equal? (car tokens) "$}")
           (if (zero? level)
               (values (reverse path) (cdr tokens))
               (walk (cdr tokens) (cons (car tokens) path) (1- level))))
          (else (walk (cdr tokens)
                      (cons (car tokens) path)
                      (if (equal? (car tokens) "${")
                          (1+ level)
                          level))))))

(define (check-include file level)
  (unless (file-exists? (expand-metachez-path file))
    (error 'parse "include-stmt file does not exist" file tokens))
  (unless (zero? level)
    (error 'parse "include-stmt inside scope" tokens))
  'ok)

(define (parse tokens)
  (let ((includes (make-hashtable string-hash string=?)))
    (let walk ((tokens tokens) (level 0))
      (match tokens
        (() '())
        (("$(" . rest)
         (let-values (((_ rest) (split-upon "$)" rest)))
           (walk rest level)))
        (("$[" file "$]" . rest)
         (check-include file level)
         (if (hashtable-ref includes file #f)
             (walk rest level)
             `(,@(walk (file->statements file) 0) . ,(walk rest level))))
        (("${" . rest)
         (let-values (((stmt rest) (split-scoped rest)))
           `((scoping-stmt ,level ,(walk stmt (1+ level))) . ,(walk rest level))))
        (("$c" . rest)
         (let-values (((stmt rest) (split-upon "$." rest)))
           `((constant-stmt ,@stmt) . ,(walk rest level))))
        (("$v" . rest)
         (let-values (((stmt rest) (split-upon "$." rest)))
           `((variable-stmt ,@stmt) . ,(walk rest level))))
        (("$d" . rest)
         (let-values (((stmt rest) (split-upon "$." rest)))
           `((disjoint-stmt ,@stmt) . ,(walk rest level))))
        ((name "$f" typecode var "$." rest ...)
         `((floating-stmt ,name ,typecode ,var) . ,(walk rest level)))
        ((name "$e" typecode . rest)
         (let-values (((stmt rest) (split-upon "$." rest)))
           `((essential-stmt ,name ,typecode ,stmt) . ,(walk rest level))))
        ((name "$a" typecode . rest)
         (let-values (((stmt rest) (split-upon "$." rest)))
           `((axiom-stmt ,name ,typecode ,stmt) . ,(walk rest level))))
        ((name "$p" typecode . rest)
         (let-values (((lhs rest) (split-upon "$=" rest)))
           (let-values (((rhs rest) (split-upon "$." rest)))
             `((provable-stmt ,name ,typecode ,lhs ,rhs) . ,(walk rest level)))))
        (_ (error 'parse "TODO" tokens))))))

(define (run-parser file)
  (parse (file->statements file)))
